# HOFNet

This package provides a multi-scale learning model for hydrogen-bonded organic framework (HOF) materials, called HOFNet. The model employs a multimodal materials transformer architecture, specifically designed for HOF materials, by incorporating three pretraining tasks that are better suited for HOFs: Pore Volume Fraction Prediction (VFP), Hydrogen Bond Position Prediction (HBP), and Molecular Fingerprint Prediction (FPP). These tasks allow HOFNet to learn structural information about HOFs at different scales. The model has achieved outstanding performance on the solvent property prediction task for HOFs using a small dataset of HOFs. HOFNet, pre-trained on 621 real HOF samples (or augmented with synthetic HOF data generated by HOFDiff), outperforms all current materials pretraining models in downstream solvent-type prediction tasks.

## Installation

Note: This package has been primarily tested on Linux. We strongly recommend using Linux for installation.

> ```python
> python>=3.8
> ```

Since MOFTransformer is based on PyTorch, please install PyTorch (>= 1.12.0) according to your environment.

### Installation via pip

```bash
$ pip install hofnet
```

## Getting Started

### Zeo++ for Porosity Calculation

In this project, **Zeo++** is used to compute the **porosity of hydrogen-bonded organic frameworks (HOFs)**. Porosity is a key physical property that influences gas adsorption performance, and Zeo++ enables efficient and accurate geometric analysis of porous materials.

You can download and install Zeo++ by following the instructions at the official website:

[Download Zeo++](https://www.zeoplusplus.org/)

---

### Download Pretrained Models (Checkpoint Files)

We provide pretrained **HOFNet** model checkpoints to accelerate your downstream experiments. These models are stored on Figshare and can be directly downloaded via the following link:

[Download HOFNet pretrained checkpoints (.ckpt)](https://figshare.com/articles/dataset/HOFNet/28856495)

**Recommended path:** After downloading, place the checkpoint files in the `./ckpt` directory of the project.

---

### Download HOFs Data

The HOF datasets used in this project, including real-world HOF structures, are available for download at the link below:

[Download HOFSyn dataset (hof_database_cifs_raw.zip)](https://figshare.com/articles/dataset/HOFSyn/28856483)

**After extracting** `hof_database_cifs_raw.zip`, you will get a folder named `hof_database_cifs_raw` which contains the collected real HOF structures.

**Recommended path:** Place the extracted data folder inside `./data`.

### Data Preprocessing

```python
from hofnet.examples import example_path
from hofnet.utils import prepare_data

# Example paths for CIFs and dataset
root_cifs = "./data/hof_database_cifs_raw"
root_dataset = "./data/hof_database_cifs_raw"

# Run data preparation
prepare_data(root_cifs, root_dataset, downstream=None)
```

### Calculating Molecular Fingerprints, HOF Pore Volume Fraction (VFP), and Hydrogen Bonds

```bash
# Calculate molecular fingerprints using cal_fp.py:
python cal_fp.py --input_file "./data/real_hofs.json" --output_file "./data/hofs_fp.json" --cifs_path "./data/hof_database_cifs_raw" --timeout 10

# Calculate hydrogen bonds using cal_hbond.py:
python cal_hbond.py --input_file "./data/real_hofs.json"  --output_file "./data/hofs_hbond.json" --cifs_path "./data/hof_database_cifs_raw"

# Calculate pore volume fraction using cal_vfp.py:
python cal_vfp.py --input_file "./data/real_hofs.json" --output_file "./data/hofs_vfp.json" --cifs_path "./data/hof_database_cifs_raw" --ZEO_PATH "./zeo++-0.3/network" --radius "0.5" --num_sample "50000" --max_workers 8
```

In this project, molecular fingerprints, hydrogen bond positions, and pore volume fractions for the training, validation, and test sets have already been computed and saved in `/data/HOF_{}/fold{}` directories.

### Pretraining

```python
import hofnet
import os
import hofnet

# real_hof + hofdiff - fold2
# real_hof - fold1
fold = 'fold1'
devices = [0,1,2,3]
max_epochs = 2000
batch_size = 8
root_dataset = f'./data/HOF_pretrain/{fold}'
cifs_path = './hof_database_cifs_raw/total'
task = 'vfp'
downstream = task

log_dir = f'./logs/HOF_pretrain/{fold}'
load_path = None
os.makedirs(log_dir, exist_ok=True)

hofnet.run(root_dataset, downstream, log_dir=log_dir,                   
                max_epochs=max_epochs, batch_size=batch_size, devices=devices, loss_names=['hbond', 'fp', 'vfp'],
                cifs_path=cifs_path, fold=fold, load_path=load_path, learning_rate=1e-5, early_stop=100)
```

### Fine-Tuning

```python
import os
from pathlib import Path
import hofnet

# real_hof + hofdiff - fold2
# real_hof - fold1
fold = 'fold0'
devices = [4]
max_epochs = 200
batch_size = 32
seed = 0               # default seeds
BASE_DATA = './data'
BASE_LOG = './logs'
root_dataset = f'{BASE_DATA}/HOF_solvent/{fold}'
task = 'solvent'
downstream = task
log_dir = f'{BASE_LOG}/solvent/fold{fold}/finetune'
os.makedirs(log_dir, exist_ok=True)
cifs_path = './data/hof_database_cifs_raw/total'
load_path = './ckpt/pretrain_real_hofdiff_best.ckpt'  # Pretrained model path

hofnet.run(
    root_dataset, downstream, log_dir=log_dir,                   
    max_epochs=max_epochs, batch_size=batch_size, devices=devices, 
    cifs_path=cifs_path, loss_names="solvent_classification", num_workers=4, load_path=load_path
)
```

### Testing

```python
from pathlib import Path
import pandas as pd
import numpy as np
import ast
from hofnet import predict  # Assuming hofnet is properly installed and configured


# === Configuration ===
fold = 'fold0'
task = 'solvent'
version = 0
seed = 0
checkpoint = 'best'
log_dir = Path('./logs') / task / fold
load_path = Path('./ckpt/real_hofdiff_best.ckpt')
root_dataset = f'./data/HOF_solvent/{fold}'
cifs_path = ".data/hof_database_cifs_raw/total"
devices = [0]
losses_name = 'solvent_classification'

# === Prediction ===
predict(root_dataset, load_path, cifs_path=cifs_path, downstream=task,
        save_dir=log_dir, devices=devices, loss_names=losses_name)

# === Post-process ===
solvent_csv = './solvent.csv'
result_csv = log_dir / 'updated_classification_results.csv'
df = pd.read_csv(log_dir / 'test_prediction.csv')

df['solvent_classification_logits'] = df['solvent_classification_logits'].apply(ast.literal_eval)
df['solvent_classification_labels'] = df['solvent_classification_labels'].apply(ast.literal_eval)
df.to_csv(result_csv, index=False)

solvents_df = pd.read_csv(solvent_csv)
solvents_df['properties'] = solvents_df[['LogP', 'Area', 'donors', 'acceptors', 'point']].values.tolist()

def mse(y_true, y_pred):
    return np.mean((np.array(y_true) - np.array(y_pred)) ** 2)

def multi_top_accuracy(true_labels, predictions):
    correct = sum(true in preds for true, preds in zip(true_labels, predictions))
    return correct / len(true_labels)

for col in ['top1_solvent', 'top2_solvent', 'top3_solvent', 'true_solvent']:
    df[col] = ""

for index, row in df.iterrows():
    pred_vec = row['solvent_classification_logits']
    true_vec = row['solvent_classification_labels']
    mse_scores = solvents_df['properties'].apply(lambda x: mse(x, pred_vec))
    top3_indices = mse_scores.nsmallest(3).index
    top3_labels = solvents_df.loc[top3_indices, 'solvent1_label'].tolist()

    df.at[index, 'top1_solvent'] = top3_labels[0]
    df.at[index, 'top2_solvent'] = top3_labels[1]
    df.at[index, 'top3_solvent'] = top3_labels[2]

    true_mse_scores = solvents_df['properties'].apply(lambda x: mse(x, true_vec))
    best_match_index = true_mse_scores.idxmin()
    df.at[index, 'true_solvent'] = solvents_df.at[best_match_index, 'solvent1_label']

df.to_csv(result_csv, index=False)

true_labels = df['true_solvent'].tolist()
top1_preds = df['top1_solvent'].tolist()
top2_preds = df[['top1_solvent', 'top2_solvent']].values.tolist()
top3_preds = df[['top1_solvent', 'top2_solvent', 'top3_solvent']].values.tolist()

top1_accuracy = multi_top_accuracy(true_labels, [[pred] for pred in top1_preds])
top2_accuracy = multi_top_accuracy(true_labels, top2_preds)
top3_accuracy = multi_top_accuracy(true_labels, top3_preds)

print(f"Top1 Accuracy: {top1_accuracy:.4f}")
print(f"Top2 Accuracy: {top2_accuracy:.4f}")
print(f"Top3 Accuracy: {top3_accuracy:.4f}")
```